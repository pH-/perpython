<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<style>
	body {
		background-color: #ffffff;
		margin: 0;
		overflow: hidden;
	}
	</style>
</head>
<body>
	<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r57/three.min.js"></script>
	<script src="http://js.leapmotion.com/leap-0.6.2.min.js"></script>
	<script>

	var camera, scene, renderer;
	var geometry, material, mesh;
	var strokePointDiffs=[];
	var stroke;
	var mousedown = false;
	var propogateRope = false;
	var getStroke = false;
	var previousFrame = null;

	var init = function () {

		renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.z = 9;

		scene = new THREE.Scene();

		var ambientLight= new THREE.AmbientLight( 0x020202 )
		scene.add( ambientLight)
		var frontLight  = new THREE.DirectionalLight('white', 1)
		frontLight.position.set(0.5, 0.5, 2)
		scene.add( frontLight )
		var backLight   = new THREE.DirectionalLight('white', 0.75)
		backLight.position.set(-0.5, -0.5, -2)
		scene.add( backLight )      

		geometry = new THREE.CubeGeometry( 1, 1, 1 );
		material = new THREE.MeshBasicMaterial( { color: 0x404000, wireframe: true, wireframeLinewidth: 5 } );
		mesh = new THREE.Mesh( geometry, material );
		scene.add( mesh );

		geometry = new THREE.PlaneGeometry( 20, 5 );
		material = new THREE.MeshLambertMaterial( {color: 0x080808, side: THREE.DoubleSide} );
		plane = new THREE.Mesh( geometry, material );
		plane.rotation.x = Math.PI/2;
		scene.add( plane )

		geometry = new THREE.Geometry();
		material = new THREE.LineBasicMaterial( {color: 0xff0000, wireframeLinewidth: 5} );
		geometry.dynamic = true;
		stroke = new THREE.Line(geometry, material);

	}

	var animate = function () 
	{

		requestAnimationFrame( animate );

		mesh.rotation.x = Date.now() * 0.0005;
		mesh.rotation.y = Date.now() * 0.001;

		animateLine();
		renderer.render( scene, camera );
	}

	var controllerOptions = {enableGestures: true};
	Leap.loop(controllerOptions, function(frame) {
		if (!getStroke) {    
                    return; // Skip this update
                }

                if(frame.pointables.length>0) {
                	for (var i = 0; i < frame.pointables.length; i++) {
                		var pointable = frame.pointables[i];
                		if(pointable.type == 1) {

                			var newDiff = new THREE.Vector3();
                			if(stroke.geometry.vertices.length >1) {
                				newDiff.subVectors(newPoint, stroke.geometry.vertices[stroke.geometry.vertices.length-1]);
                				strokePointDiffs.push(newDiff);
                			}
                			geometry.vertices.push(pointable.stabilizedTipPosition);
                			stroke.geometry.verticesNeedUpdate = true;

                		}
                	}
                }
                if (frame.gestures.length > 0) {
                	for (var i = 0; i < frame.gestures.length; i++) {
                		var gesture = frame.gestures[i];
                		if(gesture.type == "keyTap") {
                			if(getStroke == true) {
                				propogateRope = true;
                			} else {
                				propogateRope = false;
                				scene.remove(stroke);
                				geometry = new THREE.Geometry();
                				material = new THREE.LineBasicMaterial( {color: 0xff0000, wireframeLinewidth: 5} );
                				geometry.dynamic = true;
                				stroke = new THREE.Line(geometry, material);
                				strokePointDiffs = [];
                				scene.add(stroke);
                			}
                			toggleStrokeCapture();
                		}
                	}
                }

            });

function toggleStrokeCapture() 
{
	getStroke = !getStroke;
}

function animateLine() 
{ 
	if(stroke.geometry.vertices.length >1 && propogateRope) {
		firstDiff = strokePointDiffs.shift();
		stroke.geometry.vertices.shift();
		console.log(firstDiff);
		var newPoint = new THREE.Vector3();
		newPoint.addVectors(stroke.geometry.vertices.slice(-1), firstDiff);

		strokePointDiffs.push(firstDiff);               
		stroke.geometry.vertices.push(newPoint);
		stroke.geometry.verticesNeedUpdate = true;
	}
}

init();
animate();

</script>
</body>
</html>
